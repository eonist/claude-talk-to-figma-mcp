<!--
  UI panel markup for Claude MCP Figma plugin.

  This HTML file defines the structure and style of the plugin's user interface,
  including connection controls (port input, connect/disconnect buttons),
  tabs for navigation, and a progress display section.

  The UI logic and communication with the plugin backend are handled by the
  corresponding 'ui.ts' script.

  @module ui/html
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Claude MCP Plugin</title>
    <style>
/* styles.css */
/* Theme is now handled by Figma's built-in CSS variables */
:root {
  /* Custom variables that don't have Figma equivalents */
  --button-primary-hover: #0d8ee0;
  --button-secondary-hover: #d0d0d0;
  --box-bg: var(--figma-color-bg-secondary);
  --header-bg: var(--figma-color-bg-secondary);
  --accent-color: var(--figma-color-bg-brand);
  --heading-color: var(--figma-color-text);
}

/* Base styles */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Helvetica, Arial, sans-serif;
  margin: 0;
  padding: 20px;
  color: var(--figma-color-text);
  background-color: var(--figma-color-bg);
  transition: all 0.3s ease;
}

/* Theme toggle button */
.theme-toggle-container {
  margin-left: auto;
  padding-left: 10px;
}
.container {
  display: flex;
  flex-direction: column;
  height: 100%;
}
h1 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 10px;
  color: var(--heading-color);
}
h2 {
  font-size: 14px;
  font-weight: 600;
  margin-top: 20px;
  margin-bottom: 8px;
  color: var(--heading-color);
}
button {
  background-color: var(--figma-color-bg-brand);
  border: none;
  color: var(--figma-color-text-on-brand);
  padding: 8px 12px;
  border-radius: 6px;
  margin-top: 8px;
  margin-bottom: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
}
button:hover {
  background-color: var(--button-primary-hover);
}
button.secondary {
  background-color: var(--figma-color-bg-secondary);
  color: var(--figma-color-text);
}
button.secondary:hover {
  background-color: var(--button-secondary-hover);
}
button:disabled {
  background-color: var(--figma-color-bg-disabled);
  color: var(--figma-color-text-disabled);
  cursor: not-allowed;
}
input {
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
  background-color: var(--figma-color-bg);
  color: var(--figma-color-text);
}
label {
  display: block;
  margin-bottom: 4px;
  font-size: 12px;
  font-weight: 500;
  color: var(--figma-color-text-secondary);
}
.section {
  margin-bottom: 24px;
}
.hidden {
  display: none;
}
.logo {
  width: 50px;
  height: 50px;
}
.link {
  color: var(--figma-color-bg-brand);
  text-decoration: none;
  cursor: pointer;
}
.link:hover {
  text-decoration: underline;
}


/* connection.css */
/* Status and connection colors */
:root {
  --header-logo-bg: #333;
  --header-text-secondary: #999999;
  --status-connected-bg: #1a472a;
  --status-connected-text: #4ade80;
  --status-disconnected-bg: #471a1a;
  --status-disconnected-text: #ff9999;
  --status-info-bg: #1a3147;
  --status-info-text: #66b3ff;
}

/* Light theme status colors */
body.theme-light {
  --header-logo-bg: #e0e0e0;
  --header-text-secondary: #666666;
  --status-connected-bg: #d6f5de;
  --status-connected-text: #0d6831;
  --status-disconnected-bg: #ffdede;
  --status-disconnected-text: #c42b2b;
  --status-info-bg: #d6ebff;
  --status-info-text: #0057b3;
}

.header {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}
.header-logo {
  height: 50px;
  width: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  background-color: var(--header-logo-bg);
}
.header-logo-image {
  width: 100%;
}
.header-text {
  margin-left: 12px;
}
.header-text h1 {
  margin: 0;
  font-size: 16px;
}
.header-text p {
  margin: 4px 0 0 0;
  font-size: 12px;
  color: var(--header-text-secondary);
}
.input-container {
  display: flex;
  gap: 8px;
}
.checkbox-container {
  display: flex;
  align-items: center;
  width: 100%;
}
.checkbox-container input[type="checkbox"] {
  width: auto;
  flex: none;
  margin: 0;
}
.checkbox-container label {
  flex: 1;
  margin-left: 8px;
  text-align: left;
  display: block;
}
.status {
  margin-top: 16px;
  padding: 12px;
  border-radius: 6px;
  font-size: 14px;
  transition: background-color 0.3s ease, color 0.3s ease;
}
.status.connected {
  background-color: var(--status-connected-bg);
  color: var(--status-connected-text);
}
.status.disconnected {
  background-color: var(--status-disconnected-bg);
  color: var(--status-disconnected-text);
}
.status.info {
  background-color: var(--status-info-bg);
  color: var(--status-info-text);
}


/* tabs.css */
/* Tab colors */
:root {
  --tab-border-color: #444444;
  --tab-text-color: #999999;
  --tab-active-border: #18a0fb;
  --tab-active-text: #18a0fb;
}

/* Light theme tab colors */
body.theme-light {
  --tab-border-color: #dddddd;
  --tab-text-color: #777777;
  --tab-active-border: #18a0fb;
  --tab-active-text: #18a0fb;
}

.tabs {
  display: flex;
  border-bottom: 1px solid var(--tab-border-color);
  margin-bottom: 16px;
  transition: border-color 0.3s ease;
}
.tab {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: var(--tab-text-color);
  transition: color 0.3s ease;
}
.tab.active {
  border-bottom: 2px solid var(--tab-active-border);
  color: var(--tab-active-text);
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}


/* progress.css */
/* Progress bar colors */
:root {
  --progress-container-bg: #444;
  --progress-bar-color: #18a0fb;
  --operation-complete-color: #4ade80;
  --operation-error-color: #ff9999;
}

/* Light theme progress colors */
body.theme-light {
  --progress-container-bg: #dddddd;
  --progress-bar-color: #18a0fb;
  --operation-complete-color: #0d9f4f;
  --operation-error-color: #e64c4c;
}

.progress-bar-container {
  width: 100%;
  background-color: var(--progress-container-bg);
  border-radius: 4px;
  margin-top: 8px;
  transition: background-color 0.3s ease;
}
.progress-bar-inner {
  width: 0%;
  height: 8px;
  background-color: var(--progress-bar-color);
  border-radius: 4px;
  transition: width 0.3s, background-color 0.3s ease;
}
.progress-details {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 12px;
}
.operation-complete {
  color: var(--operation-complete-color);
  transition: color 0.3s ease;
}
.operation-error {
  color: var(--operation-error-color);
  transition: color 0.3s ease;
}


</style>
  </head>
  <body>
    <div class="container">
      <!-- Header Component -->
<div class="header">
  <div class="header-logo"><img src="" alt="empty"></div>
  <div class="header-text">
    <h1>Claude Talk To Figma Plugin</h1>
    <p>Connect Figma to Claude AI using MCP</p>
  </div>
</div>


      <!-- Tabs Navigation Component -->
<div class="tabs">
  <div id="tab-connection" class="tab active">Connection</div>
  <div id="tab-about" class="tab">About</div>
</div>


      <!-- Connection Panel Component -->
<div id="content-connection" class="tab-content active">
  <div class="section">
    <label for="port">WebSocket Server Port</label>
    <div class="input-container">
      <input
        type="number"
        id="port"
        placeholder="3055"
        value="3055"
        min="1024"
        max="65535"
      />
      <button id="btn-connect" class="primary">Connect</button>
    </div>
  </div>
  <div class="section">
    <div class="checkbox-container">
      <input type="checkbox" id="auto-reconnect-toggle" checked>
      <label for="auto-reconnect-toggle">Enable auto-reconnect</label>
    </div>
  </div>

  <div id="connection-status" class="status disconnected">
    Not connected to Claude MCP server
  </div>

  <div class="section">
    <button id="btn-disconnect" class="secondary" disabled>
      Disconnect
    </button>
  </div>
</div>

      
      <!-- Progress Container Component -->
<div id="progress-container" class="section hidden">
  <h2>Operation Progress</h2>
  <div id="progress-message">No operation in progress</div>
  <div class="progress-bar-container">
    <div id="progress-bar" class="progress-bar-inner"></div>
  </div>
  <div class="progress-details">
    <div id="progress-status">Not started</div>
    <div id="progress-percentage">0%</div>
  </div>
</div>

      
      <!-- About Panel Component -->
<div id="content-about" class="tab-content">
  <div class="section">
    <h2>About Claude Talk To Figma Plugin</h2>
    <p>
      This plugin allows Claude AI to communicate with Figma, enabling
      AI-assisted design operations. Based on work by
      <a
        class="link"
        onclick="window.open(`https://github.com/sonnylazuardi`, '_blank')"
        >Sonny</a
      >
    </p>
    <p>Version: 1.0.0</p>

    <h2>How to Use</h2>
    <ol>
      <li>Make sure the MCP server is running in Claude Desktop</li>
      <li>Connect to the server using the port number (default: 3055)</li>
      <li>Once connected, you can interact with Figma through Claude</li>
    </ol>
  </div>
</div>

    </div>

    <script>
/* state.js */
/**
 * Global state management for the Claude MCP Figma plugin.
 * Provides a central store for application state that can be accessed by all modules.
 */

// WebSocket connection state
const pluginState = {
  connection: {
    connected: false,
    socket: null,
    serverPort: 3055,
    pendingRequests: new Map(),
    channel: null,
    autoReconnect: true, // Track auto-reconnect setting, default to true
    reconnectAttempts: 0, // Track reconnection attempts
    maxReconnectAttempts: 5, // Maximum reconnection attempts with backoff
    inPersistentRetryMode: false, // Track if we're in persistent retry mode (8 second interval)
    persistentRetryDelay: 8000, // Persistent retry delay in ms (8 seconds)
    reconnectTimer: null, // Timer for reconnection attempts
    countdownTimer: null, // Timer for updating the countdown display
    countdownSeconds: 0, // Current countdown value in seconds
  },
  ui: {
    // UI state properties
  },
  // Add other shared state as needed
};


/* connection.js */
/**
 * WebSocket connection management for the Claude MCP Figma plugin.
 * Handles establishing and maintaining connections to the MCP server.
 */

// Helper to generate unique IDs
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

// Generate random channel name
function generateChannelName() {
  const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < 8; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

// Calculate reconnect delay with exponential backoff
function getReconnectDelay() {
  // Start with 1 second, then exponential backoff up to 30 seconds
  const baseDelay = 1000; 
  const maxDelay = 30000; // 30 seconds max
  const delay = Math.min(
    baseDelay * Math.pow(1.5, pluginState.connection.reconnectAttempts),
    maxDelay
  );
  return delay;
}

// Start countdown timer for reconnection
function startCountdownTimer(seconds) {
  // Clear any existing countdown timer
  clearCountdownTimer();
  
  // Set initial countdown value
  pluginState.connection.countdownSeconds = seconds;
  
  // Update UI with initial countdown value
  updateCountdownDisplay();
  
  // Set interval to update countdown every second
  pluginState.connection.countdownTimer = setInterval(() => {
    // Decrement countdown
    pluginState.connection.countdownSeconds--;
    
    // Update UI with new countdown value
    updateCountdownDisplay();
    
    // If countdown reaches 0, clear the interval
    if (pluginState.connection.countdownSeconds <= 0) {
      clearCountdownTimer();
    }
  }, 1000); // Update every second
}

// Clear countdown timer
function clearCountdownTimer() {
  if (pluginState.connection.countdownTimer) {
    clearInterval(pluginState.connection.countdownTimer);
    pluginState.connection.countdownTimer = null;
  }
}

// Update the UI with current countdown value
function updateCountdownDisplay() {
  if (pluginState.connection.inPersistentRetryMode) {
    const seconds = pluginState.connection.countdownSeconds;
    updateConnectionStatus(
      false, 
      `Continuing to retry connection... Reconnecting in ${seconds} second${seconds !== 1 ? 's' : ''}...`
    );
  }
}

// Attempt to reconnect to the WebSocket server
function attemptReconnect() {
  // Clear any existing reconnect timer
  if (pluginState.connection.reconnectTimer) {
    clearTimeout(pluginState.connection.reconnectTimer);
    pluginState.connection.reconnectTimer = null;
  }
  
  // Clear any existing countdown timer
  clearCountdownTimer();
  
  let delay;
  let statusMessage;
  
  // Check if we've exhausted the initial exponential backoff attempts
  if (pluginState.connection.reconnectAttempts >= pluginState.connection.maxReconnectAttempts && !pluginState.connection.inPersistentRetryMode) {
    // Switch to persistent retry mode
    pluginState.connection.inPersistentRetryMode = true;
    delay = pluginState.connection.persistentRetryDelay;
    statusMessage = `Initial reconnection attempts failed. Continuing to retry every ${Math.round(delay/1000)} seconds...`;
  } 
  else if (pluginState.connection.inPersistentRetryMode) {
    // We're already in persistent retry mode
    delay = pluginState.connection.persistentRetryDelay;
    statusMessage = `Continuing to retry connection every ${Math.round(delay/1000)} seconds...`;
  } 
  else {
    // Still in exponential backoff phase
    pluginState.connection.reconnectAttempts++;
    delay = getReconnectDelay();
    statusMessage = `Connection lost. Reconnecting in ${Math.round(delay/1000)} seconds... (Attempt ${pluginState.connection.reconnectAttempts}/${pluginState.connection.maxReconnectAttempts})`;
  }
  
  // Update UI to show reconnection attempt
  updateConnectionStatus(false, statusMessage);
  
  // Schedule reconnection
  pluginState.connection.reconnectTimer = setTimeout(() => {
    // Clear countdown timer before reconnection attempt
    clearCountdownTimer();
    
    const attemptMessage = pluginState.connection.inPersistentRetryMode
      ? `Attempting to reconnect... (persistent retry mode)`
      : `Attempting to reconnect... (Attempt ${pluginState.connection.reconnectAttempts}/${pluginState.connection.maxReconnectAttempts})`;
      
    updateConnectionStatus(false, attemptMessage);
    connectToServer(pluginState.connection.serverPort);
  }, delay);
  
  // Start countdown timer if in persistent retry mode
  if (pluginState.connection.inPersistentRetryMode) {
    startCountdownTimer(Math.round(delay/1000));
  }
}

// Connect to WebSocket server
async function connectToServer(port) {
  try {
    if (pluginState.connection.connected && pluginState.connection.socket) {
      updateConnectionStatus(true, "Already connected to server");
      return;
    }

    // Clear any existing socket
    if (pluginState.connection.socket) {
      pluginState.connection.socket.close();
      pluginState.connection.socket = null;
    }

    pluginState.connection.serverPort = port;
    pluginState.connection.socket = new WebSocket(`ws://localhost:${port}`);

    pluginState.connection.socket.onopen = () => {
      // Reset reconnection state on successful connection
      pluginState.connection.reconnectAttempts = 0;
      pluginState.connection.inPersistentRetryMode = false;
      
      // Generate random channel name
      const channelName = generateChannelName();
      console.log("Joining channel:", channelName);
      pluginState.connection.channel = channelName;

      // Join the channel using the same format as App.tsx
      pluginState.connection.socket.send(
        JSON.stringify({
          type: "join",
          channel: channelName.trim(),
        })
      );
    };

    pluginState.connection.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log("Received message:", data);

        if (data.type === "system") {
          // Successfully joined channel
          if (data.message && data.message.result) {
            pluginState.connection.connected = true;
            const channelName = data.channel;
            updateConnectionStatus(
              true,
              `Connected to server on port ${port} in channel: <strong>${channelName}</strong>`
            );

            // Notify the plugin code
            parent.postMessage(
              {
                pluginMessage: {
                  type: "notify",
                  message: `Connected to Claude MCP server on port ${port} in channel: ${channelName}`,
                },
              },
              "*"
            );
          }
        } else if (data.type === "error") {
          console.error("Error:", data.message);
          updateConnectionStatus(false, `Error: ${data.message}`);
          pluginState.connection.socket.close();
        }

        handleSocketMessage(data);
      } catch (error) {
        console.error("Error parsing message:", error);
      }
    };

    pluginState.connection.socket.onclose = (event) => {
      console.log(`WebSocket closed with code: ${event.code}, reason: ${event.reason || 'No reason provided'}`);
      pluginState.connection.connected = false;

      // If auto-reconnect is enabled and this wasn't an intentional disconnect
      if (pluginState.connection.autoReconnect && event.code !== 1000) {
        // Attempt to reconnect
        attemptReconnect();
      } else {
        // Otherwise, just update status to disconnected
        pluginState.connection.socket = null;
        updateConnectionStatus(false, "Disconnected from server");
      }
    };

    pluginState.connection.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      updateConnectionStatus(false, "Connection error");
      pluginState.connection.connected = false;
      
      // If auto-reconnect is enabled, the onclose handler will be triggered next
      // and will handle reconnection attempts
    };
  } catch (error) {
    console.error("Connection error:", error);
    updateConnectionStatus(
      false,
      `Connection error: ${error.message || "Unknown error"}`
    );
  }
}

// Disconnect from websocket server
function disconnectFromServer() {
  // Clear any reconnection timers
  if (pluginState.connection.reconnectTimer) {
    clearTimeout(pluginState.connection.reconnectTimer);
    pluginState.connection.reconnectTimer = null;
  }
  
  // Clear any countdown timer
  clearCountdownTimer();
  
  // Reset reconnection attempts and state
  pluginState.connection.reconnectAttempts = 0;
  pluginState.connection.inPersistentRetryMode = false;
  
  if (pluginState.connection.socket) {
    // Use code 1000 for normal closure to indicate intentional disconnect
    pluginState.connection.socket.close(1000, "User initiated disconnect");
    pluginState.connection.socket = null;
    pluginState.connection.connected = false;
    updateConnectionStatus(false, "Disconnected from server");
  }
}

// Send a command to the WebSocket server
async function sendCommand(command, params) {
  return new Promise((resolve, reject) => {
    if (!pluginState.connection.connected || !pluginState.connection.socket) {
      reject(new Error("Not connected to server"));
      return;
    }

    const id = generateId();
    pluginState.connection.pendingRequests.set(id, { resolve, reject });

    pluginState.connection.socket.send(
      JSON.stringify({
        id,
        type: "message",
        channel: pluginState.connection.channel,
        message: {
          id,
          command,
          params,
        },
      })
    );

    // Set timeout to reject the promise after 30 seconds
    setTimeout(() => {
      if (pluginState.connection.pendingRequests.has(id)) {
        pluginState.connection.pendingRequests.delete(id);
        reject(new Error("Request timed out"));
      }
    }, 30000);
  });
}

// Send success response back to WebSocket
function sendSuccessResponse(id, result) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send response: socket not connected");
    return;
  }

  pluginState.connection.socket.send(
    JSON.stringify({
      id,
      type: "message",
      channel: pluginState.connection.channel,
      message: {
        id,
        result,
      },
    })
  );
}

// Send error response back to WebSocket
function sendErrorResponse(id, errorMessage) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send error response: socket not connected");
    return;
  }

  pluginState.connection.socket.send(
    JSON.stringify({
      id,
      error: errorMessage,
    })
  );
}

// Send operation progress update to server
function sendProgressUpdateToServer(progressData) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send progress update: socket not connected");
    return;
  }
  
  console.log("Sending progress update to server:", progressData);
  
  pluginState.connection.socket.send(
    JSON.stringify({
      id: progressData.commandId,
      type: "progress_update",
      channel: pluginState.connection.channel,
      message: {
        id: progressData.commandId,
        type: "progress_update",
        data: progressData
      }
    })
  );
}


/* ui-controller.js */
/**
 * UI Controller for the Claude MCP Figma plugin.
 * Handles UI state updates and interactions.
 */

// UI Elements
let portInput;
let connectButton;
let disconnectButton;
let connectionStatus;
let autoReconnectToggle;
let progressContainer;
let progressBar;
let progressMessage;
let progressStatus;
let progressPercentage;

// Initialize UI elements
function initUIElements() {
  portInput = document.getElementById("port");
  connectButton = document.getElementById("btn-connect");
  disconnectButton = document.getElementById("btn-disconnect");
  connectionStatus = document.getElementById("connection-status");
  autoReconnectToggle = document.getElementById("auto-reconnect-toggle");
  
  // Progress tracking elements
  progressContainer = document.getElementById("progress-container");
  progressBar = document.getElementById("progress-bar");
  progressMessage = document.getElementById("progress-message");
  progressStatus = document.getElementById("progress-status");
  progressPercentage = document.getElementById("progress-percentage");
  
  // Set up event listeners
  connectButton.addEventListener("click", () => {
    const port = parseInt(portInput.value, 10) || 3055;
    updateConnectionStatus(false, "Connecting...");
    connectionStatus.className = "status info";
    connectToServer(port);
  });

  disconnectButton.addEventListener("click", () => {
    updateConnectionStatus(false, "Disconnecting...");
    connectionStatus.className = "status info";
    disconnectFromServer();
  });
  
  // Set up auto-reconnect toggle listener
  autoReconnectToggle.addEventListener("change", () => {
    pluginState.connection.autoReconnect = autoReconnectToggle.checked;
    console.log(`Auto-reconnect ${pluginState.connection.autoReconnect ? 'enabled' : 'disabled'}`);
  });
  
  // Initialize auto-reconnect toggle state from pluginState
  autoReconnectToggle.checked = pluginState.connection.autoReconnect;
}

// Update connection status UI
function updateConnectionStatus(isConnected, message) {
  pluginState.connection.connected = isConnected;
  connectionStatus.innerHTML =
    message ||
    (isConnected
      ? "Connected to Claude MCP server"
      : "Not connected to Claude MCP server");
  connectionStatus.className = `status ${
    isConnected ? "connected" : "disconnected"
  }`;

  connectButton.disabled = isConnected;
  disconnectButton.disabled = !isConnected;
  portInput.disabled = isConnected;
}

// Update progress UI
function updateProgressUI(progressData) {
  // Show progress container if hidden
  progressContainer.classList.remove("hidden");
  
  // Update progress bar
  const progress = progressData.progress || 0;
  progressBar.style.width = `${progress}%`;
  progressPercentage.textContent = `${progress}%`;
  
  // Update message
  progressMessage.textContent = progressData.message || "Operation in progress";
  
  // Update status text based on operation state
  if (progressData.status === 'started') {
    progressStatus.textContent = "Started";
    progressStatus.className = "";
  } else if (progressData.status === 'in_progress') {
    progressStatus.textContent = "In Progress";
    progressStatus.className = "";
  } else if (progressData.status === 'completed') {
    progressStatus.textContent = "Completed";
    progressStatus.className = "operation-complete";
    
    // Hide progress container after 5 seconds
    setTimeout(() => {
      progressContainer.classList.add("hidden");
    }, 5000);
  } else if (progressData.status === 'error') {
    progressStatus.textContent = "Error";
    progressStatus.className = "operation-error";
  }
}

// Reset progress UI
function resetProgressUI() {
  progressContainer.classList.add("hidden");
  progressBar.style.width = "0%";
  progressMessage.textContent = "No operation in progress";
  progressStatus.textContent = "Not started";
  progressStatus.className = "";
  progressPercentage.textContent = "0%";
}

// Theme handling is now managed by Figma's built-in themeColors feature
// which applies CSS variables and classes automatically


/* tab-manager.js */
/**
 * Tab Manager for the Claude MCP Figma plugin.
 * Handles tab switching functionality.
 */

let tabs;
let tabContents;

// Initialize tab navigation
function initTabNavigation() {
  // Get all tab elements and content
  tabs = document.querySelectorAll(".tab");
  tabContents = document.querySelectorAll(".tab-content");
  
  // Add click event to tabs
  tabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      // Remove active class from all tabs and contents
      tabs.forEach((t) => t.classList.remove("active"));
      tabContents.forEach((c) => c.classList.remove("active"));

      // Add active class to clicked tab
      tab.classList.add("active");
      
      // Show the corresponding content
      const contentId = "content-" + tab.id.split("-")[1];
      document.getElementById(contentId).classList.add("active");
    });
  });
}


/* message-handler.js */
/**
 * Message Handler for the Claude MCP Figma plugin.
 * Processes incoming and outgoing messages between the WebSocket and plugin.
 */

// Handle messages from the WebSocket
async function handleSocketMessage(payload) {
  const data = payload.message;
  console.log("handleSocketMessage", data);

  // If it's a response to a previous request
  if (data.id && pluginState.connection.pendingRequests.has(data.id)) {
    const { resolve, reject } = pluginState.connection.pendingRequests.get(data.id);
    pluginState.connection.pendingRequests.delete(data.id);

    if (data.error) {
      reject(new Error(data.error));
    } else {
      resolve(data.result);
    }
    return;
  }

  // If it's a new command
  if (data.command) {
    try {
      // Send the command to the plugin code
      parent.postMessage(
        {
          pluginMessage: {
            type: "execute-command",
            id: data.id,
            command: data.command,
            params: data.params,
          },
        },
        "*"
      );
    } catch (error) {
      // Send error back to WebSocket
      sendErrorResponse(
        data.id,
        error.message || "Error executing command"
      );
    }
  }
}

// Initialize event listener for messages from plugin code
function initMessageListener() {
  // Listen for messages from the plugin code
  window.onmessage = (event) => {
    const message = event.data.pluginMessage;
    if (!message) return;

    console.log("Received message from plugin:", message);

    switch (message.type) {
      case "connection-status":
        updateConnectionStatus(message.connected, message.message);
        break;
      case "auto-connect":
        connectButton.click();
        break;
      case "auto-disconnect":
        disconnectButton.click();
        break;
      case "command-result":
        // Forward the result from plugin code back to WebSocket
        sendSuccessResponse(message.id, message.result);
        break;
      case "command-error":
        // Forward the error from plugin code back to WebSocket
        sendErrorResponse(message.id, message.error);
        break;
      case "command_progress":
        // Update UI with progress information
        updateProgressUI(message);
        // Forward progress update to server
        sendProgressUpdateToServer(message);
        break;
      // Theme case removed - now handled by Figma's built-in themeColors
    }
  };
}


/* main.js */
/**
 * Main entry point for the Claude MCP Figma plugin UI.
 * Initializes and coordinates all UI modules.
 */

/**
 * Detects current Figma theme and sets up observer for theme changes
 */
function setupThemeDetection() {
  // Function to handle theme changes
  function handleThemeChange() {
    const isDarkTheme = document.documentElement.classList.contains('figma-dark');
    const theme = isDarkTheme ? 'dark' : 'light';
    console.log(`Current Figma theme: ${theme}`);
    
    // Additional theme-specific logic can go here if needed
  }
  
  // Detect initial theme
  handleThemeChange();
  
  // Set up observer to detect theme changes
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        handleThemeChange();
      }
    });
  });
  
  // Start observing the HTML element for class changes
  observer.observe(document.documentElement, { attributes: true });
}

// Initialize all UI components when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize UI elements
  initUIElements();
  
  // Initialize tab navigation
  initTabNavigation();
  
  // Initialize message listener for plugin communication
  initMessageListener();
  
  // Setup theme detection using Figma's built-in theme classes
  setupThemeDetection();
  
  console.log('Claude MCP Figma plugin UI initialized');
});


</script>
  <script>
"use strict";
(() => {
  // node_modules/reconnecting-websocket/dist/reconnecting-websocket-mjs.js
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  var Event = (
    /** @class */
    /* @__PURE__ */ function() {
      function Event2(type, target) {
        this.target = target;
        this.type = type;
      }
      return Event2;
    }()
  );
  var ErrorEvent = (
    /** @class */
    function(_super) {
      __extends(ErrorEvent2, _super);
      function ErrorEvent2(error, target) {
        var _this = _super.call(this, "error", target) || this;
        _this.message = error.message;
        _this.error = error;
        return _this;
      }
      return ErrorEvent2;
    }(Event)
  );
  var CloseEvent = (
    /** @class */
    function(_super) {
      __extends(CloseEvent2, _super);
      function CloseEvent2(code, reason, target) {
        if (code === void 0) {
          code = 1e3;
        }
        if (reason === void 0) {
          reason = "";
        }
        var _this = _super.call(this, "close", target) || this;
        _this.wasClean = true;
        _this.code = code;
        _this.reason = reason;
        return _this;
      }
      return CloseEvent2;
    }(Event)
  );
  var getGlobalWebSocket = function() {
    if (typeof WebSocket !== "undefined") {
      return WebSocket;
    }
  };
  var isWebSocket = function(w) {
    return typeof w !== "undefined" && !!w && w.CLOSING === 2;
  };
  var DEFAULT = {
    maxReconnectionDelay: 1e4,
    minReconnectionDelay: 1e3 + Math.random() * 4e3,
    minUptime: 5e3,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4e3,
    maxRetries: Infinity,
    maxEnqueuedMessages: Infinity,
    startClosed: false,
    debug: false
  };
  var ReconnectingWebSocket = (
    /** @class */
    function() {
      function ReconnectingWebSocket2(url, protocols, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        this._listeners = {
          error: [],
          message: [],
          open: [],
          close: []
        };
        this._retryCount = -1;
        this._shouldReconnect = true;
        this._connectLock = false;
        this._binaryType = "blob";
        this._closeCalled = false;
        this._messageQueue = [];
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this._handleOpen = function(event) {
          _this._debug("open event");
          var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;
          clearTimeout(_this._connectTimeout);
          _this._uptimeTimeout = setTimeout(function() {
            return _this._acceptOpen();
          }, minUptime);
          _this._ws.binaryType = _this._binaryType;
          _this._messageQueue.forEach(function(message) {
            return _this._ws.send(message);
          });
          _this._messageQueue = [];
          if (_this.onopen) {
            _this.onopen(event);
          }
          _this._listeners.open.forEach(function(listener) {
            return _this._callEventListener(event, listener);
          });
        };
        this._handleMessage = function(event) {
          _this._debug("message event");
          if (_this.onmessage) {
            _this.onmessage(event);
          }
          _this._listeners.message.forEach(function(listener) {
            return _this._callEventListener(event, listener);
          });
        };
        this._handleError = function(event) {
          _this._debug("error event", event.message);
          _this._disconnect(void 0, event.message === "TIMEOUT" ? "timeout" : void 0);
          if (_this.onerror) {
            _this.onerror(event);
          }
          _this._debug("exec error listeners");
          _this._listeners.error.forEach(function(listener) {
            return _this._callEventListener(event, listener);
          });
          _this._connect();
        };
        this._handleClose = function(event) {
          _this._debug("close event");
          _this._clearTimeouts();
          if (_this._shouldReconnect) {
            _this._connect();
          }
          if (_this.onclose) {
            _this.onclose(event);
          }
          _this._listeners.close.forEach(function(listener) {
            return _this._callEventListener(event, listener);
          });
        };
        this._url = url;
        this._protocols = protocols;
        this._options = options;
        if (this._options.startClosed) {
          this._shouldReconnect = false;
        }
        this._connect();
      }
      Object.defineProperty(ReconnectingWebSocket2, "CONNECTING", {
        get: function() {
          return 0;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2, "OPEN", {
        get: function() {
          return 1;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2, "CLOSING", {
        get: function() {
          return 2;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2, "CLOSED", {
        get: function() {
          return 3;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "CONNECTING", {
        get: function() {
          return ReconnectingWebSocket2.CONNECTING;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "OPEN", {
        get: function() {
          return ReconnectingWebSocket2.OPEN;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSING", {
        get: function() {
          return ReconnectingWebSocket2.CLOSING;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSED", {
        get: function() {
          return ReconnectingWebSocket2.CLOSED;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "binaryType", {
        get: function() {
          return this._ws ? this._ws.binaryType : this._binaryType;
        },
        set: function(value) {
          this._binaryType = value;
          if (this._ws) {
            this._ws.binaryType = value;
          }
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "retryCount", {
        /**
         * Returns the number or connection retries
         */
        get: function() {
          return Math.max(this._retryCount, 0);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "bufferedAmount", {
        /**
         * The number of bytes of data that have been queued using calls to send() but not yet
         * transmitted to the network. This value resets to zero once all queued data has been sent.
         * This value does not reset to zero when the connection is closed; if you keep calling send(),
         * this will continue to climb. Read only
         */
        get: function() {
          var bytes = this._messageQueue.reduce(function(acc, message) {
            if (typeof message === "string") {
              acc += message.length;
            } else if (message instanceof Blob) {
              acc += message.size;
            } else {
              acc += message.byteLength;
            }
            return acc;
          }, 0);
          return bytes + (this._ws ? this._ws.bufferedAmount : 0);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "extensions", {
        /**
         * The extensions selected by the server. This is currently only the empty string or a list of
         * extensions as negotiated by the connection
         */
        get: function() {
          return this._ws ? this._ws.extensions : "";
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "protocol", {
        /**
         * A string indicating the name of the sub-protocol the server selected;
         * this will be one of the strings specified in the protocols parameter when creating the
         * WebSocket object
         */
        get: function() {
          return this._ws ? this._ws.protocol : "";
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "readyState", {
        /**
         * The current state of the connection; this is one of the Ready state constants
         */
        get: function() {
          if (this._ws) {
            return this._ws.readyState;
          }
          return this._options.startClosed ? ReconnectingWebSocket2.CLOSED : ReconnectingWebSocket2.CONNECTING;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ReconnectingWebSocket2.prototype, "url", {
        /**
         * The URL as resolved by the constructor
         */
        get: function() {
          return this._ws ? this._ws.url : "";
        },
        enumerable: true,
        configurable: true
      });
      ReconnectingWebSocket2.prototype.close = function(code, reason) {
        if (code === void 0) {
          code = 1e3;
        }
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
          this._debug("close enqueued: no ws instance");
          return;
        }
        if (this._ws.readyState === this.CLOSED) {
          this._debug("close: already closed");
          return;
        }
        this._ws.close(code, reason);
      };
      ReconnectingWebSocket2.prototype.reconnect = function(code, reason) {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
          this._connect();
        } else {
          this._disconnect(code, reason);
          this._connect();
        }
      };
      ReconnectingWebSocket2.prototype.send = function(data) {
        if (this._ws && this._ws.readyState === this.OPEN) {
          this._debug("send", data);
          this._ws.send(data);
        } else {
          var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;
          if (this._messageQueue.length < maxEnqueuedMessages) {
            this._debug("enqueue", data);
            this._messageQueue.push(data);
          }
        }
      };
      ReconnectingWebSocket2.prototype.addEventListener = function(type, listener) {
        if (this._listeners[type]) {
          this._listeners[type].push(listener);
        }
      };
      ReconnectingWebSocket2.prototype.dispatchEvent = function(event) {
        var e_1, _a;
        var listeners = this._listeners[event.type];
        if (listeners) {
          try {
            for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
              var listener = listeners_1_1.value;
              this._callEventListener(event, listener);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
        return true;
      };
      ReconnectingWebSocket2.prototype.removeEventListener = function(type, listener) {
        if (this._listeners[type]) {
          this._listeners[type] = this._listeners[type].filter(function(l) {
            return l !== listener;
          });
        }
      };
      ReconnectingWebSocket2.prototype._debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this._options.debug) {
          console.log.apply(console, __spread(["RWS>"], args));
        }
      };
      ReconnectingWebSocket2.prototype._getNextDelay = function() {
        var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;
        var delay = 0;
        if (this._retryCount > 0) {
          delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
          if (delay > maxReconnectionDelay) {
            delay = maxReconnectionDelay;
          }
        }
        this._debug("next delay", delay);
        return delay;
      };
      ReconnectingWebSocket2.prototype._wait = function() {
        var _this = this;
        return new Promise(function(resolve) {
          setTimeout(resolve, _this._getNextDelay());
        });
      };
      ReconnectingWebSocket2.prototype._getNextUrl = function(urlProvider) {
        if (typeof urlProvider === "string") {
          return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === "function") {
          var url = urlProvider();
          if (typeof url === "string") {
            return Promise.resolve(url);
          }
          if (!!url.then) {
            return url;
          }
        }
        throw Error("Invalid URL");
      };
      ReconnectingWebSocket2.prototype._connect = function() {
        var _this = this;
        if (this._connectLock || !this._shouldReconnect) {
          return;
        }
        this._connectLock = true;
        var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket2 = _d === void 0 ? getGlobalWebSocket() : _d;
        if (this._retryCount >= maxRetries) {
          this._debug("max retries reached", this._retryCount, ">=", maxRetries);
          return;
        }
        this._retryCount++;
        this._debug("connect", this._retryCount);
        this._removeListeners();
        if (!isWebSocket(WebSocket2)) {
          throw Error("No valid WebSocket class provided");
        }
        this._wait().then(function() {
          return _this._getNextUrl(_this._url);
        }).then(function(url) {
          if (_this._closeCalled) {
            return;
          }
          _this._debug("connect", { url, protocols: _this._protocols });
          _this._ws = _this._protocols ? new WebSocket2(url, _this._protocols) : new WebSocket2(url);
          _this._ws.binaryType = _this._binaryType;
          _this._connectLock = false;
          _this._addListeners();
          _this._connectTimeout = setTimeout(function() {
            return _this._handleTimeout();
          }, connectionTimeout);
        });
      };
      ReconnectingWebSocket2.prototype._handleTimeout = function() {
        this._debug("timeout event");
        this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
      };
      ReconnectingWebSocket2.prototype._disconnect = function(code, reason) {
        if (code === void 0) {
          code = 1e3;
        }
        this._clearTimeouts();
        if (!this._ws) {
          return;
        }
        this._removeListeners();
        try {
          this._ws.close(code, reason);
          this._handleClose(new CloseEvent(code, reason, this));
        } catch (error) {
        }
      };
      ReconnectingWebSocket2.prototype._acceptOpen = function() {
        this._debug("accept open");
        this._retryCount = 0;
      };
      ReconnectingWebSocket2.prototype._callEventListener = function(event, listener) {
        if ("handleEvent" in listener) {
          listener.handleEvent(event);
        } else {
          listener(event);
        }
      };
      ReconnectingWebSocket2.prototype._removeListeners = function() {
        if (!this._ws) {
          return;
        }
        this._debug("removeListeners");
        this._ws.removeEventListener("open", this._handleOpen);
        this._ws.removeEventListener("close", this._handleClose);
        this._ws.removeEventListener("message", this._handleMessage);
        this._ws.removeEventListener("error", this._handleError);
      };
      ReconnectingWebSocket2.prototype._addListeners = function() {
        if (!this._ws) {
          return;
        }
        this._debug("addListeners");
        this._ws.addEventListener("open", this._handleOpen);
        this._ws.addEventListener("close", this._handleClose);
        this._ws.addEventListener("message", this._handleMessage);
        this._ws.addEventListener("error", this._handleError);
      };
      ReconnectingWebSocket2.prototype._clearTimeouts = function() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
      };
      return ReconnectingWebSocket2;
    }()
  );
  var reconnecting_websocket_mjs_default = ReconnectingWebSocket;

  // src/claude_mcp_plugin/src/client.ts
  var autoReconnectEnabled = true;
  function setAutoReconnect(flag) {
    autoReconnectEnabled = flag;
  }
  var socket = null;
  var channel;
  var connected = false;
  var serverPort = 3055;
  var pending = /* @__PURE__ */ new Map();
  var messageHandlers = [];
  var progressHandlers = [];
  function generateChannelName() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  function connect(port) {
    if (connected || socket) return;
    serverPort = port;
    socket = autoReconnectEnabled ? new reconnecting_websocket_mjs_default(`ws://localhost:${port}`, [], {
      maxReconnectionDelay: 1e4,
      minReconnectionDelay: 1500,
      reconnectionDelayGrowFactor: 1.3,
      connectionTimeout: 4e3,
      maxRetries: Infinity
    }) : new globalThis.WebSocket(`ws://localhost:${port}`);
    const chan = generateChannelName();
    channel = chan;
    socket.onopen = () => {
      socket.send(JSON.stringify({ type: "join", channel: chan }));
    };
    socket.onmessage = (event) => {
      const raw = JSON.parse(event.data);
      if (raw.type === "progress_update" && raw.message?.data) {
        progressHandlers.forEach((h) => h(raw.message.data));
      }
      if (raw.message && raw.message.id && pending.has(raw.message.id)) {
        const { resolve, reject } = pending.get(raw.message.id);
        pending.delete(raw.message.id);
        raw.message.error ? reject(new Error(raw.message.error)) : resolve(raw.message.result);
        return;
      }
      if (raw.message) {
        messageHandlers.forEach((h) => h(raw.message));
      }
    };
    socket.onerror = () => {
      disconnect();
    };
    socket.onclose = () => {
      disconnect();
    };
    connected = true;
  }
  function disconnect() {
    if (socket) {
      socket.close();
      socket = null;
    }
    connected = false;
  }
  function onMessage(fn) {
    messageHandlers.push(fn);
  }
  function onProgress(fn) {
    progressHandlers.push(fn);
  }

  // src/claude_mcp_plugin/src/ui.ts
  var portInput = document.getElementById("port");
  var connectButton = document.getElementById("btn-connect");
  var disconnectButton = document.getElementById("btn-disconnect");
  var connectionStatus = document.getElementById("connection-status");
  var tabs = Array.from(document.querySelectorAll(".tab"));
  var tabContents = Array.from(document.querySelectorAll(".tab-content"));
  var autoReconnectToggle = document.getElementById("auto-reconnect-toggle");
  var progressContainer = document.getElementById("progress-container");
  var progressBar = document.getElementById("progress-bar");
  var progressMessage = document.getElementById("progress-message");
  var progressStatus = document.getElementById("progress-status");
  var progressPercentage = document.getElementById("progress-percentage");
  function updateConnectionStatus(isConnected, message) {
    connectionStatus.innerHTML = message ? message : isConnected ? "Connected to Claude MCP server" : "Not connected to Claude MCP server";
    connectionStatus.className = "status " + (isConnected ? "connected" : "disconnected");
    connectButton.disabled = isConnected;
    disconnectButton.disabled = !isConnected;
    portInput.disabled = isConnected;
  }
  function updateProgressUI(data) {
    progressContainer.classList.remove("hidden");
    const pct = data.progress || 0;
    progressBar.style.width = `${pct}%`;
    progressPercentage.textContent = `${pct}%`;
    progressMessage.textContent = data.message || "Operation in progress";
    if (data.status === "completed") {
      progressStatus.textContent = "Completed";
      progressStatus.className = "operation-complete";
      setTimeout(() => progressContainer.classList.add("hidden"), 5e3);
    } else if (data.status === "error") {
      progressStatus.textContent = "Error";
      progressStatus.className = "operation-error";
    } else {
      progressStatus.textContent = data.status === "started" ? "Started" : "In Progress";
      progressStatus.className = "";
    }
  }
  onMessage((msg) => {
    if (msg.type === "init-settings") {
      autoReconnectToggle.checked = msg.settings.autoReconnect;
      setAutoReconnect(msg.settings.autoReconnect);
      return;
    }
    parent.postMessage({ pluginMessage: msg }, "*");
  });
  onProgress(updateProgressUI);
  tabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      tabs.forEach((t) => t.classList.remove("active"));
      tabContents.forEach((c) => c.classList.remove("active"));
      tab.classList.add("active");
      const id = tab.id.split("-")[1];
      document.getElementById(`content-${id}`).classList.add("active");
    });
  });
  autoReconnectToggle.addEventListener("change", () => {
    setAutoReconnect(autoReconnectToggle.checked);
  });
  connectButton.addEventListener("click", () => {
    updateConnectionStatus(false, "Connecting\u2026");
    connect(parseInt(portInput.value, 10) || 3055);
  });
  disconnectButton.addEventListener("click", () => {
    updateConnectionStatus(false, "Disconnecting\u2026");
    disconnect();
  });
})();
/*! Bundled license information:

reconnecting-websocket/dist/reconnecting-websocket-mjs.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/

</script>
  
</body>
</html>
