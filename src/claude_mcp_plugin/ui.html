<!--
  UI panel markup for Claude MCP Figma plugin.

  This HTML file defines the structure and style of the plugin's user interface,
  including connection controls (port input, connect/disconnect buttons),
  tabs for navigation, and a progress display section.

  The UI logic and communication with the plugin backend are handled by the
  corresponding 'ui.ts' script.

  @module ui/html
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Claude MCP Plugin</title>
    <style>
/* styles.css */
/* Base styles */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Helvetica, Arial, sans-serif;
  margin: 0;
  padding: 20px;
  color: #e0e0e0;
  background-color: #1e1e1e;
}
.container {
  display: flex;
  flex-direction: column;
  height: 100%;
}
h1 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 10px;
  color: #ffffff;
}
h2 {
  font-size: 14px;
  font-weight: 600;
  margin-top: 20px;
  margin-bottom: 8px;
  color: #ffffff;
}
button {
  background-color: #18a0fb;
  border: none;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  margin-top: 8px;
  margin-bottom: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
}
button:hover {
  background-color: #0d8ee0;
}
button.secondary {
  background-color: #3d3d3d;
  color: #e0e0e0;
}
button.secondary:hover {
  background-color: #4d4d4d;
}
button:disabled {
  background-color: #333333;
  color: #666666;
  cursor: not-allowed;
}
input {
  border: 1px solid #444444;
  border-radius: 4px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
  background-color: #2d2d2d;
  color: #e0e0e0;
}
label {
  display: block;
  margin-bottom: 4px;
  font-size: 12px;
  font-weight: 500;
  color: #cccccc;
}
.section {
  margin-bottom: 24px;
}
.hidden {
  display: none;
}
.logo {
  width: 50px;
  height: 50px;
}
.link {
  color: #18a0fb;
  text-decoration: none;
  cursor: pointer;
}
.link:hover {
  text-decoration: underline;
}


/* connection.css */
.header {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}
.header-logo {
  height: 50px;
  width: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  background-color: #333;
}
.header-logo-image {
  width: 100%;
}
.header-text {
  margin-left: 12px;
}
.header-text h1 {
  margin: 0;
  font-size: 16px;
}
.header-text p {
  margin: 4px 0 0 0;
  font-size: 12px;
  color: #999999;
}
.input-container {
  display: flex;
  gap: 8px;
}
.checkbox-container {
  display: flex;
  align-items: center;
  width: 100%;
}
.checkbox-container input[type="checkbox"] {
  width: auto;
  flex: none;
  margin: 0;
}
.checkbox-container label {
  flex: 1;
  margin-left: 8px;
  text-align: left;
  display: block;
}
.status {
  margin-top: 16px;
  padding: 12px;
  border-radius: 6px;
  font-size: 14px;
}
.status.connected {
  background-color: #1a472a;
  color: #4ade80;
}
.status.disconnected {
  background-color: #471a1a;
  color: #ff9999;
}
.status.info {
  background-color: #1a3147;
  color: #66b3ff;
}


/* tabs.css */
.tabs {
  display: flex;
  border-bottom: 1px solid #444444;
  margin-bottom: 16px;
}
.tab {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: #999999;
}
.tab.active {
  border-bottom: 2px solid #18a0fb;
  color: #18a0fb;
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}


/* progress.css */
.progress-bar-container {
  width: 100%;
  background-color: #444;
  border-radius: 4px;
  margin-top: 8px;
}
.progress-bar-inner {
  width: 0%;
  height: 8px;
  background-color: #18a0fb;
  border-radius: 4px;
  transition: width 0.3s;
}
.progress-details {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 12px;
}
.operation-complete {
  color: #4ade80;
}
.operation-error {
  color: #ff9999;
}


</style>
  </head>
  <body>
    <div class="container">
      <!-- Header Component -->
<div class="header">
  <div class="header-logo"><img src="" alt="empty"></div>
  <div class="header-text">
    <h1>Claude Talk To Figma Plugin</h1>
    <p>Connect Figma to Claude AI using MCP</p>
  </div>
</div>


      <!-- Tabs Navigation Component -->
<div class="tabs">
  <div id="tab-connection" class="tab active">Connection</div>
  <div id="tab-about" class="tab">About</div>
</div>


      <!-- Connection Panel Component -->
<div id="content-connection" class="tab-content active">
  <div class="section">
    <label for="port">WebSocket Server Port</label>
    <div class="input-container">
      <input
        type="number"
        id="port"
        placeholder="3055"
        value="3055"
        min="1024"
        max="65535"
      />
      <button id="btn-connect" class="primary">Connect</button>
    </div>
  </div>
  <div class="section">
    <div class="checkbox-container">
      <input type="checkbox" id="auto-reconnect-toggle" checked>
      <label for="auto-reconnect-toggle">Enable auto-reconnect</label>
    </div>
  </div>

  <div id="connection-status" class="status disconnected">
    Not connected to Claude MCP server
  </div>

  <div class="section">
    <button id="btn-disconnect" class="secondary" disabled>
      Disconnect
    </button>
  </div>
</div>

      
      <!-- Progress Container Component -->
<div id="progress-container" class="section hidden">
  <h2>Operation Progress</h2>
  <div id="progress-message">No operation in progress</div>
  <div class="progress-bar-container">
    <div id="progress-bar" class="progress-bar-inner"></div>
  </div>
  <div class="progress-details">
    <div id="progress-status">Not started</div>
    <div id="progress-percentage">0%</div>
  </div>
</div>

      
      <!-- About Panel Component -->
<div id="content-about" class="tab-content">
  <div class="section">
    <h2>About Claude Talk To Figma Plugin</h2>
    <p>
      This plugin allows Claude AI to communicate with Figma, enabling
      AI-assisted design operations. Based on work by
      <a
        class="link"
        onclick="window.open(`https://github.com/sonnylazuardi`, '_blank')"
        >Sonny</a
      >
    </p>
    <p>Version: 1.0.0</p>

    <h2>How to Use</h2>
    <ol>
      <li>Make sure the MCP server is running in Claude Desktop</li>
      <li>Connect to the server using the port number (default: 3055)</li>
      <li>Once connected, you can interact with Figma through Claude</li>
    </ol>
  </div>
</div>

    </div>

    <script>
/* state.js */
/**
 * Global state management for the Claude MCP Figma plugin.
 * Provides a central store for application state that can be accessed by all modules.
 */

// WebSocket connection state
const pluginState = {
  connection: {
    connected: false,
    socket: null,
    serverPort: 3055,
    pendingRequests: new Map(),
    channel: null,
    autoReconnect: true, // Track auto-reconnect setting, default to true
    reconnectAttempts: 0, // Track reconnection attempts
    maxReconnectAttempts: 5, // Maximum reconnection attempts
    reconnectTimer: null, // Timer for reconnection attempts
  },
  ui: {
    // UI state properties
  },
  // Add other shared state as needed
};


/* connection.js */
/**
 * WebSocket connection management for the Claude MCP Figma plugin.
 * Handles establishing and maintaining connections to the MCP server.
 */

// Helper to generate unique IDs
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

// Generate random channel name
function generateChannelName() {
  const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < 8; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

// Calculate reconnect delay with exponential backoff
function getReconnectDelay() {
  // Start with 1 second, then exponential backoff up to 30 seconds
  const baseDelay = 1000; 
  const maxDelay = 30000; // 30 seconds max
  const delay = Math.min(
    baseDelay * Math.pow(1.5, pluginState.connection.reconnectAttempts),
    maxDelay
  );
  return delay;
}

// Attempt to reconnect to the WebSocket server
function attemptReconnect() {
  // Clear any existing reconnect timer
  if (pluginState.connection.reconnectTimer) {
    clearTimeout(pluginState.connection.reconnectTimer);
    pluginState.connection.reconnectTimer = null;
  }
  
  // If we've reached the max reconnect attempts, stop trying
  if (pluginState.connection.reconnectAttempts >= pluginState.connection.maxReconnectAttempts) {
    updateConnectionStatus(
      false, 
      `Reconnection failed after ${pluginState.connection.maxReconnectAttempts} attempts`
    );
    return;
  }
  
  // Increment reconnect attempts
  pluginState.connection.reconnectAttempts++;
  
  // Calculate delay with exponential backoff
  const delay = getReconnectDelay();
  
  // Update UI to show reconnection attempt
  updateConnectionStatus(
    false, 
    `Connection lost. Reconnecting in ${Math.round(delay/1000)} seconds... (Attempt ${pluginState.connection.reconnectAttempts}/${pluginState.connection.maxReconnectAttempts})`
  );
  
  // Schedule reconnection
  pluginState.connection.reconnectTimer = setTimeout(() => {
    updateConnectionStatus(false, `Attempting to reconnect... (Attempt ${pluginState.connection.reconnectAttempts}/${pluginState.connection.maxReconnectAttempts})`);
    connectToServer(pluginState.connection.serverPort);
  }, delay);
}

// Connect to WebSocket server
async function connectToServer(port) {
  try {
    if (pluginState.connection.connected && pluginState.connection.socket) {
      updateConnectionStatus(true, "Already connected to server");
      return;
    }

    // Clear any existing socket
    if (pluginState.connection.socket) {
      pluginState.connection.socket.close();
      pluginState.connection.socket = null;
    }

    pluginState.connection.serverPort = port;
    pluginState.connection.socket = new WebSocket(`ws://localhost:${port}`);

    pluginState.connection.socket.onopen = () => {
      // Reset reconnection attempts on successful connection
      pluginState.connection.reconnectAttempts = 0;
      
      // Generate random channel name
      const channelName = generateChannelName();
      console.log("Joining channel:", channelName);
      pluginState.connection.channel = channelName;

      // Join the channel using the same format as App.tsx
      pluginState.connection.socket.send(
        JSON.stringify({
          type: "join",
          channel: channelName.trim(),
        })
      );
    };

    pluginState.connection.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log("Received message:", data);

        if (data.type === "system") {
          // Successfully joined channel
          if (data.message && data.message.result) {
            pluginState.connection.connected = true;
            const channelName = data.channel;
            updateConnectionStatus(
              true,
              `Connected to server on port ${port} in channel: <strong>${channelName}</strong>`
            );

            // Notify the plugin code
            parent.postMessage(
              {
                pluginMessage: {
                  type: "notify",
                  message: `Connected to Claude MCP server on port ${port} in channel: ${channelName}`,
                },
              },
              "*"
            );
          }
        } else if (data.type === "error") {
          console.error("Error:", data.message);
          updateConnectionStatus(false, `Error: ${data.message}`);
          pluginState.connection.socket.close();
        }

        handleSocketMessage(data);
      } catch (error) {
        console.error("Error parsing message:", error);
      }
    };

    pluginState.connection.socket.onclose = (event) => {
      console.log(`WebSocket closed with code: ${event.code}, reason: ${event.reason || 'No reason provided'}`);
      pluginState.connection.connected = false;

      // If auto-reconnect is enabled and this wasn't an intentional disconnect
      if (pluginState.connection.autoReconnect && event.code !== 1000) {
        // Attempt to reconnect
        attemptReconnect();
      } else {
        // Otherwise, just update status to disconnected
        pluginState.connection.socket = null;
        updateConnectionStatus(false, "Disconnected from server");
      }
    };

    pluginState.connection.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      updateConnectionStatus(false, "Connection error");
      pluginState.connection.connected = false;
      
      // If auto-reconnect is enabled, the onclose handler will be triggered next
      // and will handle reconnection attempts
    };
  } catch (error) {
    console.error("Connection error:", error);
    updateConnectionStatus(
      false,
      `Connection error: ${error.message || "Unknown error"}`
    );
  }
}

// Disconnect from websocket server
function disconnectFromServer() {
  // Clear any reconnection timers
  if (pluginState.connection.reconnectTimer) {
    clearTimeout(pluginState.connection.reconnectTimer);
    pluginState.connection.reconnectTimer = null;
  }
  
  // Reset reconnection attempts
  pluginState.connection.reconnectAttempts = 0;
  
  if (pluginState.connection.socket) {
    // Use code 1000 for normal closure to indicate intentional disconnect
    pluginState.connection.socket.close(1000, "User initiated disconnect");
    pluginState.connection.socket = null;
    pluginState.connection.connected = false;
    updateConnectionStatus(false, "Disconnected from server");
  }
}

// Send a command to the WebSocket server
async function sendCommand(command, params) {
  return new Promise((resolve, reject) => {
    if (!pluginState.connection.connected || !pluginState.connection.socket) {
      reject(new Error("Not connected to server"));
      return;
    }

    const id = generateId();
    pluginState.connection.pendingRequests.set(id, { resolve, reject });

    pluginState.connection.socket.send(
      JSON.stringify({
        id,
        type: "message",
        channel: pluginState.connection.channel,
        message: {
          id,
          command,
          params,
        },
      })
    );

    // Set timeout to reject the promise after 30 seconds
    setTimeout(() => {
      if (pluginState.connection.pendingRequests.has(id)) {
        pluginState.connection.pendingRequests.delete(id);
        reject(new Error("Request timed out"));
      }
    }, 30000);
  });
}

// Send success response back to WebSocket
function sendSuccessResponse(id, result) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send response: socket not connected");
    return;
  }

  pluginState.connection.socket.send(
    JSON.stringify({
      id,
      type: "message",
      channel: pluginState.connection.channel,
      message: {
        id,
        result,
      },
    })
  );
}

// Send error response back to WebSocket
function sendErrorResponse(id, errorMessage) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send error response: socket not connected");
    return;
  }

  pluginState.connection.socket.send(
    JSON.stringify({
      id,
      error: errorMessage,
    })
  );
}

// Send operation progress update to server
function sendProgressUpdateToServer(progressData) {
  if (!pluginState.connection.connected || !pluginState.connection.socket) {
    console.error("Cannot send progress update: socket not connected");
    return;
  }
  
  console.log("Sending progress update to server:", progressData);
  
  pluginState.connection.socket.send(
    JSON.stringify({
      id: progressData.commandId,
      type: "progress_update",
      channel: pluginState.connection.channel,
      message: {
        id: progressData.commandId,
        type: "progress_update",
        data: progressData
      }
    })
  );
}


/* ui-controller.js */
/**
 * UI Controller for the Claude MCP Figma plugin.
 * Handles UI state updates and interactions.
 */

// UI Elements
let portInput;
let connectButton;
let disconnectButton;
let connectionStatus;
let autoReconnectToggle;
let progressContainer;
let progressBar;
let progressMessage;
let progressStatus;
let progressPercentage;

// Initialize UI elements
function initUIElements() {
  portInput = document.getElementById("port");
  connectButton = document.getElementById("btn-connect");
  disconnectButton = document.getElementById("btn-disconnect");
  connectionStatus = document.getElementById("connection-status");
  autoReconnectToggle = document.getElementById("auto-reconnect-toggle");
  
  // Progress tracking elements
  progressContainer = document.getElementById("progress-container");
  progressBar = document.getElementById("progress-bar");
  progressMessage = document.getElementById("progress-message");
  progressStatus = document.getElementById("progress-status");
  progressPercentage = document.getElementById("progress-percentage");
  
  // Set up event listeners
  connectButton.addEventListener("click", () => {
    const port = parseInt(portInput.value, 10) || 3055;
    updateConnectionStatus(false, "Connecting...");
    connectionStatus.className = "status info";
    connectToServer(port);
  });

  disconnectButton.addEventListener("click", () => {
    updateConnectionStatus(false, "Disconnecting...");
    connectionStatus.className = "status info";
    disconnectFromServer();
  });
  
  // Set up auto-reconnect toggle listener
  autoReconnectToggle.addEventListener("change", () => {
    pluginState.connection.autoReconnect = autoReconnectToggle.checked;
    console.log(`Auto-reconnect ${pluginState.connection.autoReconnect ? 'enabled' : 'disabled'}`);
  });
  
  // Initialize auto-reconnect toggle state from pluginState
  autoReconnectToggle.checked = pluginState.connection.autoReconnect;
}

// Update connection status UI
function updateConnectionStatus(isConnected, message) {
  pluginState.connection.connected = isConnected;
  connectionStatus.innerHTML =
    message ||
    (isConnected
      ? "Connected to Claude MCP server"
      : "Not connected to Claude MCP server");
  connectionStatus.className = `status ${
    isConnected ? "connected" : "disconnected"
  }`;

  connectButton.disabled = isConnected;
  disconnectButton.disabled = !isConnected;
  portInput.disabled = isConnected;
}

// Update progress UI
function updateProgressUI(progressData) {
  // Show progress container if hidden
  progressContainer.classList.remove("hidden");
  
  // Update progress bar
  const progress = progressData.progress || 0;
  progressBar.style.width = `${progress}%`;
  progressPercentage.textContent = `${progress}%`;
  
  // Update message
  progressMessage.textContent = progressData.message || "Operation in progress";
  
  // Update status text based on operation state
  if (progressData.status === 'started') {
    progressStatus.textContent = "Started";
    progressStatus.className = "";
  } else if (progressData.status === 'in_progress') {
    progressStatus.textContent = "In Progress";
    progressStatus.className = "";
  } else if (progressData.status === 'completed') {
    progressStatus.textContent = "Completed";
    progressStatus.className = "operation-complete";
    
    // Hide progress container after 5 seconds
    setTimeout(() => {
      progressContainer.classList.add("hidden");
    }, 5000);
  } else if (progressData.status === 'error') {
    progressStatus.textContent = "Error";
    progressStatus.className = "operation-error";
  }
}

// Reset progress UI
function resetProgressUI() {
  progressContainer.classList.add("hidden");
  progressBar.style.width = "0%";
  progressMessage.textContent = "No operation in progress";
  progressStatus.textContent = "Not started";
  progressStatus.className = "";
  progressPercentage.textContent = "0%";
}


/* tab-manager.js */
/**
 * Tab Manager for the Claude MCP Figma plugin.
 * Handles tab switching functionality.
 */

let tabs;
let tabContents;

// Initialize tab navigation
function initTabNavigation() {
  // Get all tab elements and content
  tabs = document.querySelectorAll(".tab");
  tabContents = document.querySelectorAll(".tab-content");
  
  // Add click event to tabs
  tabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      // Remove active class from all tabs and contents
      tabs.forEach((t) => t.classList.remove("active"));
      tabContents.forEach((c) => c.classList.remove("active"));

      // Add active class to clicked tab
      tab.classList.add("active");
      
      // Show the corresponding content
      const contentId = "content-" + tab.id.split("-")[1];
      document.getElementById(contentId).classList.add("active");
    });
  });
}


/* message-handler.js */
/**
 * Message Handler for the Claude MCP Figma plugin.
 * Processes incoming and outgoing messages between the WebSocket and plugin.
 */

// Handle messages from the WebSocket
async function handleSocketMessage(payload) {
  const data = payload.message;
  console.log("handleSocketMessage", data);

  // If it's a response to a previous request
  if (data.id && pluginState.connection.pendingRequests.has(data.id)) {
    const { resolve, reject } = pluginState.connection.pendingRequests.get(data.id);
    pluginState.connection.pendingRequests.delete(data.id);

    if (data.error) {
      reject(new Error(data.error));
    } else {
      resolve(data.result);
    }
    return;
  }

  // If it's a new command
  if (data.command) {
    try {
      // Send the command to the plugin code
      parent.postMessage(
        {
          pluginMessage: {
            type: "execute-command",
            id: data.id,
            command: data.command,
            params: data.params,
          },
        },
        "*"
      );
    } catch (error) {
      // Send error back to WebSocket
      sendErrorResponse(
        data.id,
        error.message || "Error executing command"
      );
    }
  }
}

// Initialize event listener for messages from plugin code
function initMessageListener() {
  // Listen for messages from the plugin code
  window.onmessage = (event) => {
    const message = event.data.pluginMessage;
    if (!message) return;

    console.log("Received message from plugin:", message);

    switch (message.type) {
      case "connection-status":
        updateConnectionStatus(message.connected, message.message);
        break;
      case "auto-connect":
        connectButton.click();
        break;
      case "auto-disconnect":
        disconnectButton.click();
        break;
      case "command-result":
        // Forward the result from plugin code back to WebSocket
        sendSuccessResponse(message.id, message.result);
        break;
      case "command-error":
        // Forward the error from plugin code back to WebSocket
        sendErrorResponse(message.id, message.error);
        break;
      case "command_progress":
        // Update UI with progress information
        updateProgressUI(message);
        // Forward progress update to server
        sendProgressUpdateToServer(message);
        break;
    }
  };
}


/* main.js */
/**
 * Main entry point for the Claude MCP Figma plugin UI.
 * Initializes and coordinates all UI modules.
 */

// Initialize all UI components when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize UI elements
  initUIElements();
  
  // Initialize tab navigation
  initTabNavigation();
  
  // Initialize message listener for plugin communication
  initMessageListener();
  
  console.log('Claude MCP Figma plugin UI initialized');
});


</script>
  <script src="dist/ui.js" type="module"></script>
  
</body>
</html>
